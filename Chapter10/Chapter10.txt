Chapter 10 Arrays and Pointers
一、Arrays
1.Initialization
(1)Array == composed of a series of  elements of one data type.
[1]Array declaration == tells the compiler HOW MANY ELEMENTS the array contains and WHAT THE TYPE is for these elements.

[2]The brackets ([]) identify the arrays, and the number enclosed in the brackets indicates the number of elements in the array.

[3]To access elements in an array, you identify an individual element by using its subscript number (its index), which starts with 0.

[4]Single-valued variable == scalar variable.

[5]We initialize an array by using a comma-separated list of values enclosed in braces. We can use spaces between the values and the commas, if we want.

(2)Take a look at the day_mon1.c program:
[1]It is wrong only one month in every 4 years.

[2]This program used the symbolic constant MONTHS to represent the array size, which is common and recommended. If the world switched to a 13-month calendar, we just have to modify the #define statement and do not have to track down every place in the program that uses the array size.

[3]Read-only array == the program will retrieve values from the array, but it will not try to write new values into the array.
{1}We can use the const keyword when we declare and initialize the array.

{2}This way, it makes the program treat each element in the array as a constant.

(3)Take a look at the no_data.c program:
[1]The array members are like ordinary variables: if you do not initialize them, they might have any value. The compiler is allowed to just use whatever values were already present at those memory locations.

[2]The number of items in the list should match the size of the array.

(4)Take a look at the somedata.c program:
[1]When it ran out of values from the list, it initialized the remaining elements to 0. If you do not initialize an array at all, its elements, like uninitialized ordinary variables, get garbage values, but if you partially initialize an array, the remaining elements are set to 0.

[2]We can let the compiler match the array size to the list by omitting the size from the braces.

(5)Take a look at the day_mon2.c program:
[1]When you use empty brackets to initialize an array, the compiler counts the number of items in the list and makes the array that large. That is automatic counting.

[2]The sizeof operator gives the size, in bytes, of the object, or type, following it. Dividing the size of the entire array by the size of one element tells us how many elements are in the array.

[3]A potential disadvantage of automatic counting is that errors in the number of elements could pass unnoticed.

2.Designated Initializers (C99)
(1)C99 added a new capability: designated initializers == allows you to pick and choose which elements are initialized.

(2)With C99, we can use an index in brackets in the initialization list to specify a particular element.
For example:
-------------------------------------------------------------------------------------------------------------------
int arr[6] = {[5] = 212};  // initialize arr[5] to 212
-------------------------------------------------------------------------------------------------------------------

(3)As with regular initialization, after you initialize at least one element, the uninitialized elements are set to 0.

(4)Take a look at the designate.c program:
[1]If the code follows a designated initializer with further values, as in the sequence [4] = 31, 30, 31, these further values are used to initialize the subsequent elements.

[2]If the code initializes a particular element to a value more than once, the last initialization is the one that takes effect.
For example:
In the designate.c program, the start of the initialization list initializes days[1] to 28, but that is overridden by the [1] = 29 designated initialization later.

[3]?What if we do not specify the array size?
For example:
-------------------------------------------------------------------------------------------------------------------
int stuff[] = {1, [6] = 23};  // what happens?
int staff[] = {1, [6] = 4, 9, 10};  // what happens?
-------------------------------------------------------------------------------------------------------------------

The compiler will make the array big enough to accomodate the initialization values. So stuff will have 7 elements, numbered 0-6, and staff will have 2 more elements, or 9.

3.Assigning Array Values
(1)After an array has been declared, you can assign values to array members by using an array index, or subscript.

(2)C does not let you assign 1 array to another as a unit. Nor can you use the list-in-braces form except when initializing.
For example:
-------------------------------------------------------------------------------------------------------------------
/* nonvalid array assignment */
#define SIZE 5
int main(void)
{
	int oxen[SIZE] = {5, 3, 2, 8};  /* ok here */
	int yaks[SIZE];

	yaks = oxen;  /* not allowed */
	yaks[SIZE] = oxen[SIZE];  /* out of range */
	yaks[SIZE] = {5, 3, 2, 8};  /* does not work */
}
-------------------------------------------------------------------------------------------------------------------

4.Array Bounds
(1)We have to make sure we use array indices that are within bounds. That is, we have to make sure they have values valid for the array.

(2)Take a look at the bounds.c program:
[1]The compiler does not check to see whether the indices are valid. The result of using a bad index is, in the language of the C standard, undefined.

[2]When we run the program, it might seem to work, it might work oddly, or it might abort.

(3)Not checking bounds allows a C program to run faster.

(4)To be totally safe, the compiler would have to add extra code to check the value of each index during runtime, and that would slow things down.

5.Specifying an Array Size
(1)Until the C99 standard, the answer has been that you have to use a constant integer expression between the brackets when declaring an array.

(2)Constant integer expression == one formed from integer constants.
For example: a sizeof expression is considered an integer constant, but a const value IS NOT. And the value of the expression must be greater than 0.

These cases cannot be a constant integer expression:
-------------------------------------------------------------------------------------------------------------------
float a4[-4];  // no, size must be > 0
float a6[2.5];  // no, size must be an integer
float a8[n];  // not allowed before C99
-------------------------------------------------------------------------------------------------------------------

The last declaration create a new breed of array called variable-length array, or VLA for short.

(3)VLA == allow C to become a better language for numerical computing and make it easier to convert existing libraries of FORTRAN numerical calculation routines to C. It has some restrictions: for example, we cannot initialize a VLA in its declaration.

二、Multidimensional Arrays
1.Initializing a Two-Dimensional Array
(1)We can declare array of arrays like this:
-------------------------------------------------------------------------------------------------------------------
float rain[5][12];  // array of 5 arrays of 12 floats
-------------------------------------------------------------------------------------------------------------------

[1]One way to look at this declaration is to first look at the inner portion: rain[5] means rain is an array with 5 elements. And then look at the remaining part of the declaration which is [12], that means each element is of type float[12], which means that each of the 5 elements of rain is, in itself, an array of 12 float values. That means rain[0] is the 1st element of rain which is an array of 12 floats, and rain[0][0] is a float.

(2)Take a look at the rain.c program:
[1]The computation scheme
{1}A nested loop structure like this one is natual for handling a 2-dimensional array. One loop handles the 1st subscript, and the other loop handles the 2nd subscript.

{2}Each time the outer loop cycles once, the inner loop cycles its full allotment.

[2]The initialization
{1}Its initialization uses 5 embraced lists of numbers, all enclosed by 1 outer set of braces. The data in the 1st interior set of braces is assigned to the 1st row of the array, the data in the 2nd interior set goes to the 2nd row, and so on.

{2}Mismatches between data and array sizes
If the 1st inner set of braces encloses 10 numbers, only the first 10 elements of the 1st row are affected. The last 2 elements in that row are then initialized by default to 0. If there are too many numbers enclosed in that inner set of braces, then it is an error, the numbers do not get shoved into the next row.

{3}We could omit the interior braces and just retain the 2 outermost braces. As long as we have the right number of entries, the effect is the same. If we are short of entries, however, the array is filled sequentially, row by row, until the data runs out. Then the remaining elements are initialized to 0.

For example:
-------------------------------------------------------------------------------------------------------------------
int sq[2][3] = {{5, 6}, {7, 8}};
-------------------------------------------------------------------------------------------------------------------

The result will be: {{5, 6, 0}, {7, 8, 0}}.

-------------------------------------------------------------------------------------------------------------------
int sq[2][3] = {5, 6, 7, 8};
-------------------------------------------------------------------------------------------------------------------

The result will be: {{5, 6, 7}, {8, 0, 0}}.

2.More Dimensions
(1)Everything we have said about 2-dimensional arrays can be generalized to 3-dimensional arrays and further.

(2)We can visualize a 3-dimensional array as a stack of data tables. The other way to think of it is as an array of arrays of arrays.

(3)Typically, we would use 3 nested loops to process a 3-dimensional array, 4 nested loops to process a 4-dimensional array, and so on.

三、Pointers and Arrays
1.Array notation is simply a disguised use of pointers.
(1)An array name is also the address of the 1st element of the array.

For example:
If flizny is an array, the following is true:
-------------------------------------------------------------------------------------------------------------------
flizny == &flizny[0];  // name of array is the address of the 1st element
-------------------------------------------------------------------------------------------------------------------

(2)flizny and &flizny[0] are BOTH constants because they remain fixed for the duration of the program. But they can be assigned as values to a pointer variable, and we can change the value of a variable.

2.Take a look at the pnt_add.c program:
(1)We can see that the 2nd line prints the beginning addresses of the 2 arrays, and the next line gives the result of adding 1 to the address, and so on. But the result is not what we imagined because in the result, the number of the address are not separated by 1 but other numbers.

(2)Our system is addressed by individual bytes, but type short uses 2 bytes and type double uses 8 bytes. When we say "add 1 to a pointer", C adds 1 storage unit. For arrays, that means the address is increased to the address of the next element, not just the next byte.

(3)The reason why we have to declare the sort of object to which a pointer points: the address is not enough because the computer needs to know how many bytes are used to store the object. (This is true even for pointers to scalar variables; otherwise, the *pt operation to fetch the value would not work correctly.)

3.What is meant by pointer-to-int, pointer-to-float or pointer-to-any other data object:
(1)The value of a pointer is the address of the object to which it points. How the address is represented internally is hardware dependent.
[1]byte addressable == each byte in memory is numbered sequentially.

[2]The address of a large object, such as type double variable, typically is the address of the 1st byte of the object.

(2)Applying the * operator to a pointer yields the value stored in the pointed-to object.

(3)Adding 1 to the pointer increases its value by the size, in bytes, of the pointed-to type.

4.We have the following equalities:
-------------------------------------------------------------------------------------------------------------------
dates + 2 == &date[2]  // same address
*(dates + 2) == dates[2]  // same value
-------------------------------------------------------------------------------------------------------------------

5.The C language standard describes array notation in terms of pointers, which means that it defines ar[n] to mean *(ar + n).

6.The indirection operator (*) binds more tightly (that is, has higher precedence) than +.

7.Take a look at the day_mon3.c program:
(1)days is the address of the 1st element of the array, days + index is the address of element days[index], and *(days + index) is the value of that element, just as days[index] is.

(2)Is there an advantage to writing the program this way? Not really. The compiler produces the SAME code for either.

四、Functions, Arrays, and Pointers
1.Using Pointer Parameters
(1)Suppose you want to write a function that operates on an array, what would the prototype be?
As the name of an array is the address of its 1st element, so the actual argument of it, being the address of an int, should be assigned to a formal parameter that is a pointer-to-int:
-------------------------------------------------------------------------------------------------------------------
int sum(int * ar);  // corresponding prototype
-------------------------------------------------------------------------------------------------------------------

[1]The information that sum() gets from this argument is the address of the 1st element of the array and it says nothing about the number of elements in the array.

[2]We have a couple of choices of how to get that information to the function.
{1}The 1st choice is to code a fixed array size into the function.
For example:
-------------------------------------------------------------------------------------------------------------------
int sum(int * ar)  // corresponding definition
{
	int i;
	int total = 0;

	for (i = 0; i < 10; i++)  // assume 10 elements
		total += ar[i];  // ar[i] the same as *(ar + i)
	return total;
}
-------------------------------------------------------------------------------------------------------------------

{2}A more flexible approach is to pass the array size as a 2nd argument.
For example:
-------------------------------------------------------------------------------------------------------------------
int sum(int * ar, int n)  // more general approach
{
	int i;
	int total = 0;

	for (i = 0; i < n; i++)  // use n elements
		total += ar[i];  // ar[i] the same as *(ar + i)
	return total;
}
-------------------------------------------------------------------------------------------------------------------

Here, the 1st parameter tells the function where to find the array and the type of data in the array, and the 2nd parameter tells the function how many elements are present.

[3]In the context of a function prototype or function definition header, and only in that context, you can substitute int ar[] for int * ar.

(2)Declaring Array Parameters
[1]Prototypes allow we to omit a name, all 4 of the following prototypes are equivalent:
{1}int sum(int *ar, int n);

{2}int sum(int *, int);

{3}int sum(int ar[], int n);

{4}int sum(int [], int);

[2]We cannot omit names in function definitions, so, for definitions, the following 2 forms are equivalent:
-------------------------------------------------------------------------------------------------------------------
int sum(int * ar, int n)
{
	// code goes here
}
-------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------
int sum(int ar[], int n);
{
	// code goes here
}
-------------------------------------------------------------------------------------------------------------------

(3)Take a look at the sum_arr1.c program:
[1]Note that the size of marbles is 40 bytes because marbles contains 10 ints, each 4 bytes, for a total of 40 bytes.

[2]The size of ar is just 8 bytes because ar is not an array itself, it is a pointer to the 1st element of marbles. (Other systems might use a different number of bytes.) Marbles is an array, ar is a pointer to the 1st element of marbles, and the C connection between arrays and pointers lets you use array notation with the pointer ar.

(4)A function working on an array needs to know where to start and stop.

(5)Another way to describe the array is by passing 2 pointers, with the 1st indicating where the array starts (as before) and the 2nd where the array ends.

(6)The function can alter the value of the pointer itself, making it point to each array element in turn.

(7)Take a look at the sum_arr2.c program:
[1]The pointer start begins by pointing to the 1st element of marbles, so the assignment expression total +=*start adds the value of the 1st element (20) to total. Then the expression start++ increments the pointer variable start so that it points to the next element in the array. Because start points to type int, C increments the value of start by the size of int.

[2]The pointer variable end actually points to the location after the final element in the array. When C allocates space for an array, a pointer to the 1st location after the last element of the array is a valid pointer.

[3]Although C guarantees that the pointer marbles + SIZE is a valid pointer, it makes no guarantees about marbles[SIZE], the value stored at that location, so a program should not attempt to access that location.

[4]We can also condense the body of the loop to 1 line:
-------------------------------------------------------------------------------------------------------------------
total += *start++;
-------------------------------------------------------------------------------------------------------------------

The unary operators * and ++ have the same precedence but associate from right to left. This means the ++ applies to start, not to *start. That is, the pointer is incremented, not the value pointed to.

[5]Different situations
{1}If the program used *++start, the order would be increment the pointer, then use the value pointed to.

{2}If the program used (*start)++, however, it would use the value of start and then increment the value, not the pointer. That would leave the pointer pointing to the same element, but the element would contain a new number.

2.Comment: Pointers and Arrays
(1)Using array notation makes it more obvious that the function is working with arrays. Also, array notation has a more familiar look to programmers versed in other languages. Other programmers might be more accustomed to working with pointers and might find the pointer notation more natural.

(2)As far as C goes, the 2 expressions ar[i] and *(ar+i) are equivalent in meaning. Both work if ar is the name of an array, and both work if ar is a pointer variable. However, using an expression such as ar++ only works if ar is a POINTER variable.

(3)Pointer notation, particularly when used with the increment operator, is closer to machine language and, with some compilers, leads to more efficient code.

五、Pointer Operations
1.Take a look at the ptr_ops.c program:
(1)The basic operations that can be performed with or on pointer variables:
[1]Assignment == assign an address to a pointer.
{1}Note that the address should be compatible with the pointer type. That is, we cannot assign the address of a double to a pointer-to-int, at least not without making an ill-advised type cast.

[2]Value finding (dereferencing) == use the * operator to give the value stored in the point-to location.

[3]Taking a pointer address.
{1}Like all variables, a pointer variable has an address and a value. The & operator tells you where the pointer itself is stored.

[4]Adding an integer to a pointer == we can use the + operator to add an integer to a pointer or a pointer to an integer. In either case, the integer is multiplied by the number of bytes in the pointed-to type, and the result is added to the original address.

[5]Incrementing a pointer == makes it move to the next element of the array.
{1}Note that the address of ptr1 itself remains the original one. After all, a variable does not move around just because it changes value.

[6]Subtracting an integer from a pointer
{1}The pointer has to be the 1st operand and the integer value the 2nd operand. The integer is multiplied by the number of bytes in the pointed-to type, and the result is subtracted from the original address.

{2}The result of subtraction is undefined if it lies outside of the array into which the original pointer points, except that the address one past the end element of the array is guaranteed to be valid.

[7]Decrementing a pointer
{1}We can use both the prefix and postfix forms of the increment and decrement operators.

[8]Differencing
{1}We find the difference between 2 pointers to elements that are in the same array to find out how far apart the elements are. The result is in the same units as the type size.

[9]Comparisons
{1}We can use the relational operators to compare the values of 2 pointers, provided the pointers are of the same type.

(2)There are 2 forms of subtraction. We can subtract 1 pointer from another to get an integer, and we can subtract an integer from a pointer and get a pointer.

(3)The computer does not keep track of whether a pointer still points to an array element. But the effect of incrementing or decrementing a pointer beyond these limits is undefined. Also, we can dereference a pointer to any array element. However, even though a pointer to 1 past the end element is valid, it is not guaranteed that such a one-past-the-end pointer can be dereferenced.

(4)Dereferencing an Uninitialized Pointer
[1]Do not dereference an uninitialized pointer.
For example:
-------------------------------------------------------------------------------------------------------------------
int * pt;  // an uninitialized pointer
*pt = 5;  // a terrible error
-------------------------------------------------------------------------------------------------------------------

pt is uninitialized, and it has a random value, so there is no knowing where the 5 will be placed. Creating a pointer only allocates memory to store the pointer itself, it does not allocate memory to store data.

六、Protecting Array Contents
1.Using const with Formal Parameters
(1)The usual rule == pass quantities by value unless the program needs to alter the value, in which case we pass a pointer.

(2)For arrays, we MUST pass a pointer. If a function passed an array by value, it would have to allocate enough space to hold a copy of the original array and then copy all the data from the original array to the new array. It is much quicker to pass the address of the array and have the function work with the original data.

(3)The reason C ordinarily passes data by value is to preserve the integrity of the data. If a function works with a copy of the original data, it will not accidentally modify the original data. But, because array-processing functions do work with the original data, they CAN modify the array.

(4)If a function's intent is that it not change the contents of the array, use the keyword const when declaring the formal parameter in the prototype and in the function definition.
For example:
-------------------------------------------------------------------------------------------------------------------
int sum(const int ar[], int n);  /* prototype */

int sum(const int ar[], int n)  /* definition */
{
	int i;
	int total = 0;

	for (i = 0; i < n; i++)
		total += ar[i];
	return total;
}
-------------------------------------------------------------------------------------------------------------------

If we accidentally use an expression such as ar[i]++, the compiler can catch it and generate an error message, telling you that the function is attempting to alter constant data.

(5)Using const this way does NOT require that the original array be constant, it just says that the function has to treat the array AS THOUGH it were constant.

(6)In general, if we write a function intended to modify an array, do not use const when declaring the array parameter. If we write a function not intended to modify an array, do use const when declaring the array parameter.

(7)Take a look at the arf.c program:
[1]Here, show_array function displays an array and mult_array function multiplies each element of an array by a given value. As the 1st function should not alter the array, it uses const, and as the 2nd function intends to modify the array, it does not use const.

[2]Note that both functions are type void. The mult_array() function does provide new values to the dip array, but not by using the return statement.

2.More About const
(1)const can be used to create symbolic constants, which can be accomplished by #define directive. But const additionally lets us create cosntant arrays, constant pointers, and pointers to constants.

(2)Pointers to constants cannot be used to change values
For example:
-------------------------------------------------------------------------------------------------------------------
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * pd = rates;  // pd points to beginning of the array
-------------------------------------------------------------------------------------------------------------------

[1]The 2nd line of code declares that the type double value to which pd points is a const, which means that we cannot use pd to change pointed-to values:
-------------------------------------------------------------------------------------------------------------------
*pd = 29.89;  // not allowed
pd[2] = 222.22;  // not allowed
rates[0] = 99.99;  // allowed because rates is not const
-------------------------------------------------------------------------------------------------------------------

[2]Whether we use pointer notation or array notation, we are NOT allowed to use pd to change the value of pointed-to data. However, because rates was NOT declared as a constant, we can still use rates to change values.

[3]And we can make pd point somewhere else.
For example:
-------------------------------------------------------------------------------------------------------------------
pd++;  /* make pd point to rates[1] -- allowed */
-------------------------------------------------------------------------------------------------------------------

[4]A pointer-to-constant is normally used as a function parameter to indicate that the function will NOT use the pointer to change data.
For example:
-------------------------------------------------------------------------------------------------------------------
void show_array(const double *ar, int n);
-------------------------------------------------------------------------------------------------------------------

[5]Rules about pointer assignments and const
{1}First, it is valid to assign the address of either constant data or non-constant data to a pointer-to-constant.
For example:
-------------------------------------------------------------------------------------------------------------------
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
const double * pc = rates;  // valid
pc = locked;  // valid
pc = &rates[3];  // valid
-------------------------------------------------------------------------------------------------------------------

{2}Only the addresses of non-constant data can be assigned to regular pointers.
For example:
-------------------------------------------------------------------------------------------------------------------
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double locked[4] = {0.08, 0.075, 0.0725, 0.07};
double * pc = rates;  // valid
pnc = locked;  // NOT valid
pnc = &rates[3];  // valid
-------------------------------------------------------------------------------------------------------------------

After all, we could use the pointer to change data that was supposed to be constant.

{3}Using const in a function parameter definition not only protects data, it also allows the function to work with arrays that have been declared const.

{4}An attempt to modify const data, such as locked, using a non-const identifier, results in undefined behavior.

[6]More possible uses of const
{1}We can declare and initialize a pointer so that it cannot be made to point elsewhere. The trick is the placement of the keyword const.
For example:
-------------------------------------------------------------------------------------------------------------------
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
double * const pc = rates;  // pc points to beginning of the array
pc = &rates[2];  // not allowed to point elsewhere
*pc = 92.99;  // ok -- changes rates[0]
-------------------------------------------------------------------------------------------------------------------

Such a pointer can still be used to change values, but it can point only to the location originally assigned to it.

{2}Use const twice to create a pointer that can neither change where it is pointing nor change the value to which it points.
For example:
-------------------------------------------------------------------------------------------------------------------
double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5};
const double * const pc = rates;
pc = &rates[2];  // not allowed
*pc = 92.99;  // not allowed
-------------------------------------------------------------------------------------------------------------------

七、Pointers and Multidimensional Arrays
1.Pointers to Multidimensional Arrays


2.Pointer Compatibility


3.Functions and Multidimensional Arrays


八、Variable-Length Arrays (VLAs)


九、Compound Literals

