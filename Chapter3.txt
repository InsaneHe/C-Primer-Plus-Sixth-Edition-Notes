Chapter 3 Data and C
一、A Sample Program
1.getchar() function == reads the next input character so the program has to wait for input.

For example, we can use two getchar() functions together to let the program wait instead of briefly flashing onscreen and then disappearing:
getchar();
getchar();
The first getchar() function reads the newline character, and the second one causes the program to pause.

2.What's New in This Program?
(1)%f specifier == used in the printf() code to handle a floating-point value.

(2).2 modifier == used after %f specifier, it fine-tunes the appearance of the output so that it displays 2 places to the right of the decimal.

二、Data Variables and Constants
1.Data == the numbers and characters that bear the information you use.

2.Constant == data that are preset before a program is used and keep their values unchanged throughout the life of the program.

3.Variable == data that may change or be assigned values as the program runs.

?What is the difference between constants and variables?
A variable can have its value assigned or changed while the program is running, and a constant cannot.

三、Data: Data-Type Keywords
1.Data can be divided into 2 groups: numbers & characters.

2.When a datum is a constant: the compiler can usually tell its type just by THE WAY IT LOOKS.
For example, 42 is regarded as an integer; 42.100 is regarded as floating point.

3.When a datum is a variable: needs to be have its type announced in a declaration statement.

4.The types can be divided into 2 families: integer types & floating-point types.
(Depending on how they are stored in the computer, for a human, the difference between them is the way they can be written.)

5.Integer
(1)Integer == a number with no fractional part.

(2)Never written with a decimal point!!!

(3)Stored as binary numbers.

6.Floating-Point Number
(1)Like what mathematicians call real number.

(2)Adding a decimal point makes a value a floating-point value.
For example, 7 is an integer type, but 7.00 is a floating-point type.

(3)There are more than one way to write a floating-point number.

For example, 3.16E7 means to multiply 3.16 by 10 to the 7th power (3.16*10^7); that is, by 1 followed by 7 zeros. The 7 would be termed the exponent of 10.

(4)Floating-point representation involves breaking up a number into a fractional part and an exponent part and storing the parts separately.

For example, the 7.00 would not be stored in the same manner as the integer 7. The decimal analogy would be to write 7.0 as 0.7E1 where 0.7 is the fractional part, and the 1 is the exponent part.

(5)Floating-point numbers can represent a much larger range of values than integers can.

(6)Floating-point numbers are subject to larger loss of precision for some arithmatic operations such as subtracting one large number from another.

(7)Floating-point values are often approximations of a true value.

For example, 7.0 might be stored as a 6.99999 float value.

四、Basic C Data Types
1.The int type == a signed integer.
[1]The range in possible values depends on the computer system. Normally, an int uses one machine word for storage.

For example, for system of 16-bit: the range in values from -32768 to 32767 (minimum range).

[2]One of the ways of supplying values for int variables --> Initialize.
<1>Initialize a variable == assign it a starting, or initial value by following the variable name with the assignment operator (=) and the value you want the variable to have.

<2>These declarations create and label the storage for the variables and assign starting values to each.

[3]Type int Constants
<1>integer constants == integer literals.

* C treats most integer constants as type int, very large integers can be treated differently such as the long int type.

[4]Printing int Values
<1>Format specifier: %d == an int value in the list of items to be printed, it can be an int variable, an int constant, or any other expression having an int value.

<2>Let us see the program: print1.c in which the 2nd line of output, the program uses variable "ten" to provide a value for the 1st "%d" and uses whatever values happen to be lying around in memory for the next two "%d".

* The reason why the compiler does not tell you this error is that printf() can have unlimited number of arguments, so it is best for you to remember to always check to see that the number of format specifiers you give to printf() matches the number of values to be displayed.

[5]Oval and Hexadecimal
<1>C assumes that integer constants are decimal, or base 10.

<2>Octal (base 8) & Hexadecimal (16) numbers are popular with many programmers as each digit in a hexadecimal number corresponds to exactly 4 bits.

For example, the hexadecimal digit 3 is 0011 and the hexadecimal 5 is 0101. So the hexadecimal value 35 is the bit pattern 0011 0101, and the hexadecimal value 53 is 0101 0011. This correspondence makes it easy to go back and forth between hexadecimal and binary (base 2) notation.

<3>Special Prefixes == indicate which number base you are using.
0x | 0X --> hexadecimal value --> 16 is written as 0x10 | 0X10;
0 --> octal value --> 16 is written as 020;

* This option of using different number systems does not affect how the number is stored. So you can write 16 or 020 or 0x10 and the number is stored the same way in each case and that is in the binary code.

[6]Displaying Octal and Hexadecimal
<1>%o == display an integer in octal notation.

<2>%x == display an integer in hexadecimal notation

<3>use specifiers: %#o, %#x or %#X to generate the 0, 0x or 0X prefixes respectively.

[7]Other Integer Types
<1>C offers 3 adjective keywords to modify the basic integer type: short, long and unsigned.

* short, int, long and long long are all signed type; unsigned is used for variables that have only nonnegative values and shifts the range from 0 to 65535 in value instead of from -32768 to 32767 as the bit used to indicate the sign of signed numbers now becomes another binary digit, allowing the larger number.

<2>Storage occupied: short <= int <= long <= long long (>= 64 bits).

[8]Declaring Other Integer Types
The same way as declaring int type.

[9]Why Multiple Integer Types
<1>The most common practice today is to set up long long as 64 bits, long as 32 bits, short as 16 bits and int as either 16 bits or 32 bits, depending on the machine's natural word size.

<2>Consider unsigned types first when you do not need negative numbers. Then use the long type if you need to use numbers that long can handle and that int cannot but do not use long when it is not essential. But use short only if your program uses arrays of integers that are large in relation to a system's available memory or it may correspond in size to hardware registers used by particular components in a computer.

<3>Integer Overflow
{1}Happens when an integer gets too big for its type.

* if an unsigned integer reaches its maximum value, it starts over at the beginning like integer does.

<2>The Order of Using Types
If you use a number on a system where int will not hold, the compiler will treat it as a long int, assuming this type is large enough;
If the number is larger than the long maximum, C treats it as unsigned long;
If still insufficient, C treats the value as long long or unsigned long long.
To sum up, the order of using types is: int -> long -> unsigned long -> long long -> unsigned long long.

<3>Printing short, long, long long and unsigned Types
{1}%u == print an unsigned int.

{2}%ld == print a long value.

{3}%lx == print a long integer in hexadecimal format.

{4}%lo == print a long integer in octal format.

{5}%hd == print a short integer in decimal format.

{6}%ho == print a short integer in octal format.

{7}%lld == print a signed long long integer.

{8}%llu == print a unsigned long long integer.

<4>Using the wrong specification can produce unexpected results
{1}If you tell printf() that the number is unsigned, it prints one value, and if you tell it that the same number is signed, it prints the other value as these two values printed have exactly the same internal representation in memory on our system.

{2}The short variable is displayed the same whether you tell printf() that the variable is a short or an int because C automatically expands a short value to an int when it is passed as an argument to a function.

* The computer passes the value as an int faster than passing it as a short.

<5>Using Characters: Type char
{1}char type == store characters such as letters and punctuation marks but technically called an integer type.

* The char type stores integers actually instead of characters.

<6>Character Constants and Initialization
{1}C charactor constant == a single character contains between single quotes.

!!! A character between DOUBLE quotes (" ") is considered as a STRING instead of a character!!!
!!! A character stays only between quotes (' ')!!!
