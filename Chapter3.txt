Chapter 3 Data and C
一、A Sample Program
1.getchar() function == reads the next input character so the program has to wait for input.

For example, we can use two getchar() functions together to let the program wait instead of briefly flashing onscreen and then disappearing:
getchar();
getchar();
The first getchar() function reads the newline character, and the second one causes the program to pause.

2.What's New in This Program?
(1)%f specifier == used in the printf() code to handle a floating-point value.

(2).2 modifier == used after %f specifier, it fine-tunes the appearance of the output so that it displays 2 places to the right of the decimal.

二、Data Variables and Constants
1.Data == the numbers and characters that bear the information you use.

2.Constant == data that are preset before a program is used and keep their values unchanged throughout the life of the program.

3.Variable == data that may change or be assigned values as the program runs.

?What is the difference between constants and variables?
A variable can have its value assigned or changed while the program is running, and a constant cannot.

三、Data: Data-Type Keywords
1.Data can be divided into 2 groups: numbers & characters.

2.When a datum is a constant: the compiler can usually tell its type just by THE WAY IT LOOKS.
For example, 42 is regarded as an integer; 42.100 is regarded as floating point.

3.When a datum is a variable: needs to be have its type announced in a declaration statement.

4.The types can be divided into 2 families: integer types & floating-point types.
(Depending on how they are stored in the computer, for a human, the difference between them is the way they can be written.)

5.Integer
(1)Integer == a number with no fractional part.

(2)Never written with a decimal point!!!

(3)Stored as binary numbers.

6.Floating-Point Number
(1)Like what mathematicians call real number.

(2)Adding a decimal point makes a value a floating-point value.
For example, 7 is an integer type, but 7.00 is a floating-point type.

(3)There are more than one way to write a floating-point number.

For example, 3.16E7 means to multiply 3.16 by 10 to the 7th power (3.16*10^7); that is, by 1 followed by 7 zeros. The 7 would be termed the exponent of 10.

(4)Floating-point representation involves breaking up a number into a fractional part and an exponent part and storing the parts separately.

For example, the 7.00 would not be stored in the same manner as the integer 7. The decimal analogy would be to write 7.0 as 0.7E1 where 0.7 is the fractional part, and the 1 is the exponent part.

(5)Floating-point numbers can represent a much larger range of values than integers can.

(6)Floating-point numbers are subject to larger loss of precision for some arithmatic operations such as subtracting one large number from another.

(7)Floating-point values are often approximations of a true value.

For example, 7.0 might be stored as a 6.99999 float value.

四、Basic C Data Types
1.The int type == a signed integer.
[1]The range in possible values depends on the computer system. Normally, an int uses one machine word for storage.

For example, for system of 16-bit: the range in values from -32768 to 32767 (minimum range).

[2]One of the ways of supplying values for int variables --> Initialize.
<1>Initialize a variable == assign it a starting, or initial value by following the variable name with the assignment operator (=) and the value you want the variable to have.

<2>These declarations create and label the storage for the variables and assign starting values to each.

[3]Type int Constants
<1>integer constants == integer literals.

* C treats most integer constants as type int, very large integers can be treated differently such as the long int type.

[4]Printing int Values
<1>Format specifier: %d == an int value in the list of items to be printed, it can be an int variable, an int constant, or any other expression having an int value.

<2>Let us see the program: print1.c in which the 2nd line of output, the program uses variable "ten" to provide a value for the 1st "%d" and uses whatever values happen to be lying around in memory for the next two "%d".

* The reason why the compiler does not tell you this error is that printf() can have unlimited number of arguments, so it is best for you to remember to always check to see that the number of format specifiers you give to printf() matches the number of values to be displayed.

[5]Oval and Hexadecimal
<1>C assumes that integer constants are decimal, or base 10.

<2>Octal (base 8) & Hexadecimal (16) numbers are popular with many programmers as each digit in a hexadecimal number corresponds to exactly 4 bits.

For example, the hexadecimal digit 3 is 0011 and the hexadecimal 5 is 0101. So the hexadecimal value 35 is the bit pattern 0011 0101, and the hexadecimal value 53 is 0101 0011. This correspondence makes it easy to go back and forth between hexadecimal and binary (base 2) notation.

<3>Special Prefixes == indicate which number base you are using.
0x | 0X --> hexadecimal value --> 16 is written as 0x10 | 0X10;
0 --> octal value --> 16 is written as 020;

* This option of using different number systems does not affect how the number is stored. So you can write 16 or 020 or 0x10 and the number is stored the same way in each case and that is in the binary code.

[6]Displaying Octal and Hexadecimal
<1>%o == display an integer in octal notation.

<2>%x == display an integer in hexadecimal notation

<3>use specifiers: %#o, %#x or %#X to generate the 0, 0x or 0X prefixes respectively.

[7]Other Integer Types
<1>C offers 3 adjective keywords to modify the basic integer type: short, long and unsigned.

* short, int, long and long long are all signed type; unsigned is used for variables that have only nonnegative values and shifts the range from 0 to 65535 in value instead of from -32768 to 32767 as the bit used to indicate the sign of signed numbers now becomes another binary digit, allowing the larger number.

<2>Storage occupied: short <= int <= long <= long long (>= 64 bits).

[8]Declaring Other Integer Types
The same way as declaring int type.

[9]Why Multiple Integer Types
<1>The most common practice today is to set up long long as 64 bits, long as 32 bits, short as 16 bits and int as either 16 bits or 32 bits, depending on the machine's natural word size.

<2>Consider unsigned types first when you do not need negative numbers. Then use the long type if you need to use numbers that long can handle and that int cannot but do not use long when it is not essential. But use short only if your program uses arrays of integers that are large in relation to a system's available memory or it may correspond in size to hardware registers used by particular components in a computer.

<3>Integer Overflow
{1}Happens when an integer gets too big for its type.

* if an unsigned integer reaches its maximum value, it starts over at the beginning like integer does.

<2>The Order of Using Types
If you use a number on a system where int will not hold, the compiler will treat it as a long int, assuming this type is large enough;
If the number is larger than the long maximum, C treats it as unsigned long;
If still insufficient, C treats the value as long long or unsigned long long.
To sum up, the order of using types is: int -> long -> unsigned long -> long long -> unsigned long long.

<3>Printing short, long, long long and unsigned Types
{1}%u == print an unsigned int.

{2}%ld == print a long value.

{3}%lx == print a long integer in hexadecimal format.

{4}%lo == print a long integer in octal format.

{5}%hd == print a short integer in decimal format.

{6}%ho == print a short integer in octal format.

{7}%lld == print a signed long long integer.

{8}%llu == print a unsigned long long integer.

<4>Using the wrong specification can produce unexpected results
{1}If you tell printf() that the number is unsigned, it prints one value, and if you tell it that the same number is signed, it prints the other value as these two values printed have exactly the same internal representation in memory on our system.

{2}The short variable is displayed the same whether you tell printf() that the variable is a short or an int because C automatically expands a short value to an int when it is passed as an argument to a function.

* The computer passes the value as an int faster than passing it as a short.

<5>Using Characters: Type char
{1}char type == store characters such as letters and punctuation marks but technically called an integer type.

* The char type stores integers actually instead of characters.

<6>Character Constants and Initialization
{1}C charactor constant == a single character contains between single quotes.

!!! A character between DOUBLE quotes (" ") is considered as a STRING instead of a character!!!
!!! A character stays only between quotes (' ')!!!

{2}C treats character constants as type int rather than type char.
For example:
-------------------------------------------------------------------------------------------------------------------
char grade = 'B';
-------------------------------------------------------------------------------------------------------------------

Here, 'B' is represented as the numerical value 66 stored in a 32-bit unit, but grade winds up with 66 stored in an 8-bit unit. --> This characteristic makes it possible to define a character constant such as 'FATE' by using 4 separate 8-bit ASCII codes stored in a 32-bit unit.

!!!However, this is WRONG!!!
If we do this, we will find that only the last 8 bits being used, so the variable only gets the value 'E'.

<7>Nonprinting Characters
There are 3 ways to represent Nonprinting Characters.
{1}1st way: use the ASCII code.
For example, the ASCII code for the beep character is 7, we can do this:
-------------------------------------------------------------------------------------------------------------------
char beep = 7;
-------------------------------------------------------------------------------------------------------------------

{2}2nd way: use special symbol sequences (called "escape sequences").
For example, we use "\b" to represent backspace.

* Escape sequences must be enclosed in SINGLE QUOTES when assigned to a character variable.
For example, we can do this:
-------------------------------------------------------------------------------------------------------------------
char nerf = '\n';
-------------------------------------------------------------------------------------------------------------------

Look at the alert character (\a), it produces an audible or visible alert. (Depends on the hardware, with the beep being the most common.) And the alert character shall not change the active position, which means it cannot change the location on the display device at which the next character would otherwise appear.

Sometimes, we might see some expressions like "\0oo" or "\xhh", they are special representations of the ASCII code. If we want to represent a character by its octal ASCII code, we can precede it with a backslash and enclose the whole thing in single quotes.
For example, if you want to represent the alert character by using its ASCII code, we can do this:
-------------------------------------------------------------------------------------------------------------------
beep = '/007';
-------------------------------------------------------------------------------------------------------------------

We can also omit the leading zeros, such as '\07' or '\7' to represent the same thing.

We can also use a hexadecimal form for character constants by making the backslash followed by an x or X and one to three hexadecimal digits.
For example, the Ctrl+P character has an ASCII hex code of 10 (which is 16 in decimal), so it can be expressed as '\x10' or '\X010'.

Here is the figure showing some representative integer types:
					Examples of Integer Constants
---------------------------------------------------------------------
type 				|	hexadecimal 	|	octal 	| 	decimal 	|
---------------------------------------------------------------------
char 				|	\0x41 			|	\0101 	| 	N.A. 		|
---------------------------------------------------------------------
int 				|	0x41 			|	0101 	| 	65 		    |
---------------------------------------------------------------------
unsigned int 		|	0x41u 			|	0101u 	| 	65u 		|
---------------------------------------------------------------------
long 				|	0x41L 			|	0101L 	| 	65L 		|
---------------------------------------------------------------------
unsigned long 		|	0x41UL 			|	0101UL 	| 	65UL 		|
---------------------------------------------------------------------
long long 			|	0x41LL 			|	0101LL 	| 	65LL 		|
---------------------------------------------------------------------
unsigned long long 	|	0x41ULL 		|	0101ULL | 	65ULL 		|
---------------------------------------------------------------------

?Why are not the escape sequences enclosed in single quotes?
When a character, be it an escape sequence or not, is part of a string of characters enclosed in double quotes, do not enclose it in single quotes.

* Character String == a string of characters enclosed in double quotes.

?When should I use the ASCII code, and when should I use the escape sequences?
When we have a choice, we should use the escape sequences. Because they are more mnemonic and more portable.

<8>The _Bool Type
{1}Boolean values == the logical values "true" & "false". C uses the value 1 for true and 0 for false. Thus the _Bool type is just an integer type and only requires 1 bit of memory.

<9>Portable Types: stdint.h and inttypes.h
{1}How to reach such an aim: let C have types that have the same meaning regardless of the system?
The answer is that C creates more names for the existing types, and to define these new names, we use a header file "stdint.h".

{2}Exact-width integer type
For example, int32_t == the type for a 32-bit signed integer. But a system that uses 32-bit int defines it as an alias for int; another system that uses 16-bit int and 32-bit long defines it (the same) as an alias for long. And if we use int32_t type to write programs and include stdint.h, the compiler will substitute int or long for the type in a manner appropriate for your particular program.

* int32_t is exactly 32 bits, no less or no more.

!!!There is a chance that the underlying system might not support these choices.

?What if a system cannot support exact-width types?
There is a second category of alternative names that are required. --> Minimum Width Types.

{3}Minimum Width Types
Minimum Width Types == promises the type is at least big enough to meet the specification and that no other type that can do the job is smaller.
For example, the int_fast8_t will be defined as an alternative name for the integer type on your system that allows the fastest calculations for 8-bit signed values.

{4}intmax_t == a type that can hold any valid signed integer value; uintmax_t == the largest available unsigned type.

{5}As printf() needs specific specifiers to print particular types, but some requires "%d" to print int32_t, others might require "%ld" to print it, there are some "string macros" to be used to display the portable types.
For example, the inttypes.h header file defines PRId32 as a string representing the appropriate specifier for a 32-bit signed value.

<10>Types float, double, and long double
{1}Floating -point numbers == type float, double, or long double. It enables you to represent a much greater range of numbers, including decimal fractions. This representation is similar to scientific notation.
For example:
-------------------------------------------------------------------------
Number 			| 	Scientific Notation 	| 	Exponential Notation 	|
-------------------------------------------------------------------------
1,000,000,000 	| 	= 1.0*10^9 				| 	= 1.0e9 				|
-------------------------------------------------------------------------
123,000 		| 	= 1.23*10^5 			|	= 1.23e5 				|
-------------------------------------------------------------------------
322.56 			| 	= 3.2256*10^2 			|	= 3.2256e2				|
-------------------------------------------------------------------------
0.000056 		| 	= 5.6*10^(-5) 			| 	= 5.6e-5				|
-------------------------------------------------------------------------

The 1st column is the usual notation; the 2nd column is the scientific notation; the 3rd column is the exponential notation, or e-notation, which is the way scientific notation is usually written for and by computers, with the e followed by the power of 10.

{2}A float has to be able to represent at least 6 significant figures and allow a range of at least 10^(-37) to 10^37.

For "6 significant figures" part, as a float has to represent accurately at least the first 6 digits in a number such as 33.333333.

For "a range of at least 10^(-37) to 10^37" part, systems often use 32 bits to store a floating-point number, among these 32 bits, 8 bits are used to give the exponent its value and sign, and the 24 bits are used to represent the nonexponent part, called the mantissa or significand, and its sign.
For example: a float: 1.6e-19, "1.6" is represented by the 24 bits, and "-19" is represented by the 8 bits.

{3}Another float type provided by C is double. Typical double representations use 64 bits instead of 32. It also has the same minimum range requirements as float, but it extends the minumum number of significant figures that can be represented to 10.

{4}The 3rd floating-point type provided by C is long double, which is at least as precise as double.

<11>Floating-Point Constants (Literals)
